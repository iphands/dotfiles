#!/bin/bash
# Ban script - blocks SSH brute-force attackers using firewall
#
# Purpose:
#   Scans journalctl for SSH failed password attempts and adds
#   firewall rules to block offending IP addresses.
#
# Data format (badactors.db):
#   IP<TAB>LAST_SEEN_EPOCH<TAB>FIRST_SEEN_EPOCH<TAB>HIT_COUNT
#
# Whitelist format (whitelist.txt):
#   One entry per line: IP, IPv6, or hostname (resolved via getent)
#
# Usage:
#   ./ban          # Scan last 300 minutes of logs
#   ./ban FULL     # Scan last 7 days of logs
#
set -eo pipefail

# Must run as root
if [[ "$(id -u)" -ne 0 ]]; then
    echo "Error: must run as root" >&2
    exit 1
fi

# Prevent concurrent runs
LOCK_FILE="/var/lock/ssh-ban.lock"
exec 200>"$LOCK_FILE"
flock -n 200 || { echo "Error: another instance is running" >&2; exit 1; }

# Constants for expiration
MAX_AGE_DAYS=10
SECONDS_PER_DAY=86400
MAX_AGE_SECONDS=$((MAX_AGE_DAYS * SECONDS_PER_DAY))

# File paths
DB_FILE="/root/ban/badactors.db"
BANLOG_FILE="/root/ban/.ban.log"
MY_IP_FILE="/root/ban/myip.txt"
WHITELIST_FILE="/root/ban/whitelist.txt"

# Old files to clean up (migration)
OLD_LIST_FILE="/root/ban/.ip.list.txt"
OLD_LIST_RAW="/root/ban/.ip.list.txt.raw"
OLD_LIST_BAK="/root/ban/.ip.list.txt.bak"

# Associative arrays for tracking IPs
declare -A ip_last_seen
declare -A ip_first_seen
declare -A ip_hit_count
declare -A whitelist_ips

# Detect IP family (ipv4 or ipv6)
get_ip_family() {
    local ip="$1"
    if [[ "$ip" == *":"* ]]; then
        echo "ipv6"
    else
        echo "ipv4"
    fi
}

# Check if string looks like a valid IP address
is_valid_ip() {
    local ip="$1"
    # Basic check: contains only valid IP characters and is non-empty
    [[ -n "$ip" && "$ip" =~ ^[0-9a-fA-F.:]+$ ]]
}

# Load database from TSV file into associative arrays
load_database() {
    if [[ -f "$DB_FILE" ]]; then
        while IFS=$'\t' read -r ip last first count; do
            ip_last_seen["$ip"]="$last"
            ip_first_seen["$ip"]="$first"
            ip_hit_count["$ip"]="$count"
        done < "$DB_FILE"
    fi
}

# Save associative arrays to TSV file with atomic write
save_database() {
    local temp_file="${DB_FILE}.tmp.$$"
    {
        for ip in "${!ip_last_seen[@]}"; do
            echo -e "${ip}\t${ip_last_seen[$ip]}\t${ip_first_seen[$ip]}\t${ip_hit_count[$ip]}"
        done
    } > "$temp_file"
    mv "$temp_file" "$DB_FILE"
}

# Check if IP is older than MAX_AGE_DAYS
is_expired() {
    local ip="$1"
    local now=$(date +%s)
    local last_seen="${ip_last_seen[$ip]:-0}"
    local age=$((now - last_seen))
    [[ $age -gt $MAX_AGE_SECONDS ]]
}

# Add new IP or refresh existing IP's timestamp
add_or_refresh_ip() {
    local ip="$1"
    local now=$(date +%s)
    
    if [[ -z "${ip_last_seen[$ip]}" ]]; then
        # New IP
        ip_last_seen["$ip"]="$now"
        ip_first_seen["$ip"]="$now"
        ip_hit_count["$ip"]="1"
    else
        # Existing IP - refresh timestamp and increment count
        ip_last_seen["$ip"]="$now"
        ip_hit_count["$ip"]=$((ip_hit_count[$ip] + 1))
    fi
}

# Count non-expired IPs in database
count_active_ips() {
    local count=0
    for ip in "${!ip_last_seen[@]}"; do
        if ! is_expired "$ip"; then
            ((count++))
        fi
    done
    echo "$count"
}

# Create default whitelist file with examples if it doesn't exist
create_default_whitelist() {
    if [[ ! -f "$WHITELIST_FILE" ]]; then
        cat > "$WHITELIST_FILE" << 'EOF'
# SSH Ban Whitelist
# One entry per line. Supports:
# - IPv4 addresses (e.g., 192.168.1.100)
# - IPv6 addresses (e.g., 2001:db8::1)
# - Hostnames (resolved at runtime via getent)
# - Comments start with #

# Example trusted IPs
# 192.168.1.100
# trusted-server.example.com
EOF
        echo "Created default whitelist: $WHITELIST_FILE"
    fi
}

# Migrate MY_IP_FILE to whitelist on first run
migrate_myip_to_whitelist() {
    if [[ -f "$MY_IP_FILE" && ! -f "$WHITELIST_FILE" ]]; then
        echo "# Migrated from myip.txt on $(date)" > "$WHITELIST_FILE"
        cat "$MY_IP_FILE" >> "$WHITELIST_FILE"
        rm "$MY_IP_FILE"
        echo "Migrated $MY_IP_FILE to $WHITELIST_FILE"
    fi
}

# Resolve hostnames in whitelist to IP addresses
resolve_whitelist() {
    whitelist_ips=()
    
    if [[ ! -f "$WHITELIST_FILE" ]]; then
        return
    fi
    
    while IFS= read -r entry || [[ -n "$entry" ]]; do
        # Skip empty lines and comments
        [[ -z "$entry" || "$entry" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace
        entry=$(echo "$entry" | xargs)
        
        # Check if it looks like an IP (contains . or :) or a hostname
        if [[ "$entry" == *"."* || "$entry" == *":"* ]]; then
            # Looks like an IP - add directly
            whitelist_ips["$entry"]=1
        else
            # Try to resolve hostname
            local resolved_ips
            resolved_ips=$(getent hosts "$entry" 2>/dev/null | awk '{print $1}')
            if [[ -n "$resolved_ips" ]]; then
                while read -r ip; do
                    [[ -n "$ip" ]] && whitelist_ips["$ip"]=1
                done <<< "$resolved_ips"
            else
                echo "Warning: Could not resolve hostname: $entry"
            fi
        fi
    done < "$WHITELIST_FILE"
}

# Check if an IP is in the whitelist
is_whitelisted() {
    local ip="$1"
    [[ -n "${whitelist_ips[$ip]}" ]]
}

# Parse command line arguments
if [ "$1" != "FULL" ]
then
  opt="300 minutes ago"
else
  opt="7 days ago"
fi

# Load existing database
load_database

# Initialize whitelist (migrate old myip.txt, create default, resolve hostnames)
migrate_myip_to_whitelist
create_default_whitelist
resolve_whitelist

# Get old count (non-expired IPs)
OLD_COUNT=$(count_active_ips)

# Find bad actors from journalctl
echo "Finding bad actors"
while IFS= read -r IP; do
    [[ -n "$IP" ]] && is_valid_ip "$IP" && add_or_refresh_ip "$IP"
done < <(time journalctl -u sshd --since="${opt}" | fgrep 'Failed password' | fgrep ' from ' | grep -oE 'from ([0-9]{1,3}\.){3}[0-9]{1,3}|from ([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}' | cut -f2 -d' ')

# Save updated database
save_database

# Bounce firewall
echo "Bouncing firewall"
firewall-cmd --reload

# Get my IP (if file still exists - may have been migrated to whitelist)
if [[ -f "$MY_IP_FILE" ]]; then
    MY_IP=$(cat "$MY_IP_FILE")
else
    MY_IP=""
fi

# Add non-expired IPs to firewall
echo "Adding bad actors"
for ip in "${!ip_last_seen[@]}"; do
    if ! is_expired "$ip"; then
        # Skip whitelisted IPs and MY_IP
        if is_whitelisted "$ip"; then
            continue
        fi
        if [[ -n "$MY_IP" && "$MY_IP" == "$ip" ]]; then
            continue
        fi
        family=$(get_ip_family "$ip")
        echo "  adding $ip"
        firewall-cmd --add-rich-rule="rule family='${family}' source address='$ip' reject"
    fi
done

# Log counts
echo "Old count:"
echo "$OLD_COUNT"

NEW_COUNT=$(count_active_ips)
echo "New count:"
echo "$NEW_COUNT"
echo "$NEW_COUNT $(date)" >> "$BANLOG_FILE"

# Clean up old files (one-time migration)
for old_file in "$OLD_LIST_FILE" "$OLD_LIST_RAW" "$OLD_LIST_BAK"; do
    if [[ -f "$old_file" ]]; then
        echo "Removing old file: $old_file"
        rm "$old_file"
    fi
done
